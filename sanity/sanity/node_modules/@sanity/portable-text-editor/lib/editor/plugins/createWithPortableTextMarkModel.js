"use strict";
/**
 *
 * This plugin will change Slate's default marks model (every prop is a mark) with the Portable Text model (marks is an array of strings on prop .marks).
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithPortableTextMarkModel = void 0;
const lodash_1 = require("lodash");
const slate_1 = require("slate");
const debug_1 = require("../../utils/debug");
const selection_1 = require("../../utils/selection");
const debug = debug_1.debugWithName('plugin:withPortableTextMarkModel');
function createWithPortableTextMarkModel(portableTextFeatures, keyGenerator, change$) {
    return function withPortableTextMarkModel(editor) {
        const { apply, normalizeNode } = editor;
        const decorators = portableTextFeatures.decorators.map(t => t.value);
        // Extend Slate's default normalization. Merge spans with same set of .marks when doing merge_node operations
        editor.normalizeNode = nodeEntry => {
            normalizeNode(nodeEntry);
            const [node, path] = nodeEntry;
            const isBlock = node._type === portableTextFeatures.types.block.name;
            const isSpan = node._type === portableTextFeatures.types.span.name;
            // Check consistency of markDefs
            if (isBlock &&
                editor.operations.some(op => ['split_node', 'remove_node', 'remove_text', 'merge_node'].includes(op.type))) {
                normalizeMarkDefs(editor);
            }
            if (isSpan) {
                if (!node.marks) {
                    debug('Adding .marks to span node');
                    slate_1.Transforms.setNodes(editor, { marks: [] }, { at: path });
                }
                if (editor.operations.some(op => [
                    'insert_node',
                    'insert_text',
                    'merge_node',
                    'remove_node',
                    'remove_text',
                    'set_node'
                ].includes(op.type))) {
                    mergeSpans(editor);
                }
                // Make sure we don't continue marks on a new empty block when the current one is split
                for (const op of editor.operations) {
                    if (op.type === 'split_node' &&
                        op.path.length === 1 &&
                        op.path[0] === path[0] &&
                        !slate_1.Path.equals(path, op.path)) {
                        const [child] = slate_1.Editor.node(editor, [op.path[0] + 1, 0]);
                        if (child.text === '') {
                            debug(`Removing leftover marks for new empty block`, op);
                            slate_1.Transforms.setNodes(editor, { marks: [] }, { at: [op.path[0] + 1, 0], voids: false });
                            editor.onChange();
                            break;
                        }
                    }
                }
            }
            // This should not be needed? Commented out for now.
            // // Ensure that every span node has .marks
            // const [node, path] = nodeEntry
            // if (node._type === portableTextFeatures.types.span.name) {
            //   if (!node.marks) {
            //     debug('Adding .marks to span node')
            //     Transforms.setNodes(editor, {marks: []}, {at: path})
            //   }
            // }
        };
        // Special hook before inserting text at the end of an annotation.
        editor.apply = op => {
            var _a;
            if (op.type === 'insert_text') {
                const { selection } = editor;
                if (selection && slate_1.Range.isCollapsed(selection) && ((_a = slate_1.Editor.marks(editor)) === null || _a === void 0 ? void 0 : _a.marks.some(mark => !decorators.includes(mark)))) {
                    const [node] = Array.from(slate_1.Editor.nodes(editor, {
                        mode: 'lowest',
                        at: selection.focus,
                        match: n => n._type === portableTextFeatures.types.span.name,
                        voids: false
                    }))[0] || [undefined];
                    if (node &&
                        node.text &&
                        typeof node.text === 'string' &&
                        node.text.length === selection.focus.offset &&
                        Array.isArray(node.marks) &&
                        node.marks.length > 0) {
                        apply(op);
                        slate_1.Transforms.splitNodes(editor, {
                            match: slate_1.Text.isText,
                            at: Object.assign(Object.assign({}, selection.focus), { offset: selection.focus.offset })
                        });
                        const marksWithoutAnnotationMarks = (Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || []).filter(mark => decorators.includes(mark));
                        slate_1.Transforms.setNodes(editor, { marks: marksWithoutAnnotationMarks }, { at: slate_1.Path.next(selection.focus.path) });
                        return;
                    }
                }
            }
            apply(op);
        };
        // Override built in addMark function
        editor.addMark = (mark) => {
            if (editor.selection) {
                if (slate_1.Range.isExpanded(editor.selection)) {
                    // Split if needed
                    slate_1.Transforms.setNodes(editor, {}, { match: slate_1.Text.isText, split: true });
                    // Use new selection
                    const splitTextNodes = [
                        ...slate_1.Editor.nodes(editor, { at: editor.selection, match: slate_1.Text.isText })
                    ];
                    const shouldRemoveMark = lodash_1.flatten(splitTextNodes.map(item => item[0]).map(node => node.marks)).includes(mark);
                    if (shouldRemoveMark) {
                        editor.removeMark(mark);
                        return;
                    }
                    splitTextNodes.forEach(([node, path]) => {
                        const marks = [
                            ...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),
                            mark
                        ];
                        slate_1.Transforms.setNodes(editor, { marks }, { at: path });
                    });
                }
                else {
                    const existingMarks = Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
                    const marks = Object.assign(Object.assign({}, (slate_1.Editor.marks(editor) || {})), { marks: [...existingMarks, mark] });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        // Override built in removeMark function
        editor.removeMark = (mark) => {
            if (editor.selection) {
                if (slate_1.Range.isExpanded(editor.selection)) {
                    // Split if needed
                    slate_1.Transforms.setNodes(editor, {}, { match: slate_1.Text.isText, split: true });
                    const splitTextNodes = [
                        ...slate_1.Editor.nodes(editor, { at: editor.selection, match: slate_1.Text.isText })
                    ];
                    splitTextNodes.forEach(([node, path]) => {
                        slate_1.Transforms.setNodes(editor, {
                            marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark)
                        }, { at: path });
                    });
                }
                else {
                    const existingMarks = Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
                    const marks = Object.assign(Object.assign({}, (slate_1.Editor.marks(editor) || {})), { marks: existingMarks.filter(eMark => eMark !== mark) });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        editor.pteIsMarkActive = (mark) => {
            if (!editor.selection) {
                return false;
            }
            let existingMarks = Object.assign({}, (slate_1.Editor.marks(editor) || {})).marks || [];
            if (slate_1.Range.isExpanded(editor.selection)) {
                Array.from(slate_1.Editor.nodes(editor, { match: slate_1.Text.isText, at: editor.selection })).forEach(n => {
                    const [node] = n;
                    existingMarks = lodash_1.uniq([...existingMarks, ...(node.marks || [])]);
                });
            }
            return existingMarks.includes(mark);
        };
        // Custom editor function to toggle a mark
        editor.pteToggleMark = (mark) => {
            const isActive = editor.pteIsMarkActive(mark);
            if (isActive) {
                debug(`Remove mark '${mark}'`);
                slate_1.Editor.removeMark(editor, mark);
            }
            else {
                debug(`Add mark '${mark}'`);
                slate_1.Editor.addMark(editor, mark, true);
            }
            const newSelection = selection_1.toPortableTextRange(editor);
            if (newSelection) {
                // Emit a new selection here (though it might be the same).
                // This is for toolbars etc that listens to selection changes to update themselves.
                change$.next({ type: 'selection', selection: newSelection });
            }
            editor.onChange();
        };
        return editor;
    };
    /**
     * Normalize re-marked spans in selection
     * @param {Editor} editor
     */
    function mergeSpans(editor) {
        const { selection } = editor;
        if (selection) {
            for (const [node, path] of Array.from(slate_1.Editor.nodes(editor, {
                at: slate_1.Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]])
            })).reverse()) {
                const [parent] = path.length > 1 ? slate_1.Editor.node(editor, slate_1.Path.parent(path)) : [undefined];
                const nextPath = [path[0], path[1] + 1];
                if (slate_1.Editor.isBlock(editor, parent)) {
                    const nextNode = parent.children[nextPath[1]];
                    if (node._type === 'span' &&
                        nextNode &&
                        nextNode._type === 'span' &&
                        lodash_1.isEqual(nextNode.marks, node.marks)) {
                        debug('Merging spans');
                        slate_1.Transforms.mergeNodes(editor, { at: nextPath, voids: true });
                        editor.onChange();
                    }
                }
            }
        }
    }
    /**
     * Normalize markDefs
     *
     * @param {Editor} editor
     */
    function normalizeMarkDefs(editor) {
        const { selection } = editor;
        if (selection) {
            const blocks = slate_1.Editor.nodes(editor, {
                at: selection,
                match: n => n._type === portableTextFeatures.types.block.name
            });
            for (const [block, path] of blocks) {
                if (Array.isArray(block.markDefs) && slate_1.Element.isElement(block)) {
                    const newMarkDefs = block.markDefs.filter(def => {
                        return block.children.find(child => {
                            return Array.isArray(child.marks) && child.marks.includes(def._key);
                        });
                    });
                    const isEmptySingleChild = block.markDefs.length > 0 &&
                        block.children.length === 1 &&
                        block.children[0].text === '';
                    if (!lodash_1.isEqual(newMarkDefs, block.markDefs) || isEmptySingleChild) {
                        debug('Removing markDef not in use');
                        slate_1.Transforms.setNodes(editor, {
                            markDefs: isEmptySingleChild ? [] : newMarkDefs
                        }, { at: path });
                        editor.onChange();
                    }
                }
            }
        }
    }
}
exports.createWithPortableTextMarkModel = createWithPortableTextMarkModel;
//# sourceMappingURL=createWithPortableTextMarkModel.js.map